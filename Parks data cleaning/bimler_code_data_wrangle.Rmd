---
title: "bimler_code_data_wrangle"
output: html_document
date: "2024-08-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# loading in data
```{r}
library(tidyverse)

wir_focals_dat <- read.csv("focals/wir fitness(WIR diverse focals).csv")
wir_neighborhoods_data <- read.csv("neighborhoods/wir fitness(WIR neighborhoods).csv")

br_focals_dat <- read.csv("focals/br fitness(BR diverse focals).csv")
br_neighborhoods_data <- read.csv("neighborhoods/br fitness(BR neighborhoods).csv")

sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")

rf_focals_dat <- read.csv("focals/riverfront fitness(Riverfront Diverse focals).csv")
rf_neighborhoods_data <- read.csv("neighborhoods/riverfront fitness(RIVERFRONT neighborhoods.csv")

```

# fixing column names for neighborhood data
```{r}
fix_col_names <- function(data){
  #setting column names to values of 1st row
  colnames(data) <- data [1, ]
  
  # removing 1st row
  data <- data[-1,]
  
  return (data)
}

wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
rf_neighborhoods_data <- fix_col_names(rf_neighborhoods_data)
br_neighborhoods_data <- fix_col_names(br_neighborhoods_data)

# filtering the neighborhoods so that we keep only the ones that have focal collects 
  # to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
# wir doesn't have a 'focal collect' column
# rf also doesn't have a 'focal collect' column
# unique(br_neighborhoods_data$`focal collect?`), br focal collect column is just blanks ("")
```

# cleaning the TOPFR and SIDEFR columns' counts into one column
```{r}
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
  # calculating the average side and tops in the function
  
  average_top <- mean(data$TOPFR, na.rm = TRUE)
  average_side <- mean(data$SIDEFR, na.rm = TRUE)
  
  if(!is.na(data[row, 'TOPFR']) & !is.na(data[row, 'SIDEFR'])){
    return((data[row, 'TOPFR']) + ((data[row, "TOTALFR"] - 1) * data[row, 'SIDEFR']))
  }
  else{
    return(average_top + ((data[row, 'TOTALFR'] - 1) * average_side))
  }
}


# only want to apply the function to NAV and COLLOM 
nav_and_collom <- c("NAVSQU", "COLLOM")


```

# SEM fixing fruit counts 
```{r}
###
# modifying TOTAL.FR to TOTALFR for fxn to work
  # new name = old name
sem_focals_dat <- sem_focals_dat %>% rename(TOTALFR = TOTAL.FR)

# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]

# 10.5
# mean(nav_and_collom_only_sem$TOPFR, na.rm = TRUE)
# 2.944444
# mean(nav_and_collom_only_sem$SIDEFR, na.rm = TRUE)

# applying function to the filtered nav/collom dataset and creating a column called 'new_fruit_count'
nav_and_collom_only_sem$new_fruit_count <- sapply(1:nrow(nav_and_collom_only_sem), function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem))
# this is creating a new column called new_fruit_count

# JUST FOR NAV AND COLLOM, merging our new values created from the above sapply in the "new_fruit_count", using coalesce to see if there's new values in new_fruit_count, if not, taking from TOTALFR column 
nav_and_collom_only_sem <- nav_and_collom_only_sem %>%
  mutate(fruits = coalesce(new_fruit_count, TOTALFR))
#so the new column with all of the fruit counts is now in a column called "fruits"
# but this still keeps all of the columns so there's another column in this dataframe that 

# Merge the new column back to the original dataframe
# removing all nav and collom instances from the main dataframe so that we can merge our newly created fruit counts for ONLY nav and collom back into the larger dataset
sem_focals_dat_no_nav_or_collom <- sem_focals_dat[!(sem_focals_dat$SPECIES %in% c("NAVSQU", "COLLOM")), ]

# coalesce fruits for epiden (EXACTFR) and the rest of the focal species (TOTALFR) into one fruits column
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>%
  mutate(fruits = coalesce(EXACTFR, TOTALFR))


# we are really only interested in the columns: fruits, species, and keeping plot, plot.1, subplot, and park for merging purposes
nav_and_collom_only_sem <- nav_and_collom_only_sem %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)


# now merging the nav_and_collom_only_sem with sem_focals_dat_no_nav_or_collom to get the full dataset!!
sem_updated_focals <- rbind(sem_focals_dat_no_nav_or_collom, nav_and_collom_only_sem)
```



# WIR changing fruit count
```{r}

#working with wir_focals_dat
colnames(wir_focals_dat)
  # for fruits we have TOTALFR = the initial total fruit counts we took at the parks
  # EXACTFR = The EPIDEN fruit counts
  # TOPFR, SIDEFR is the top and side counts for NAVSQU and COLLOM

# attempting to create a function to do everything that I did above

update_fruit_counts <- function(data, species_to_update, calculate_new_fruit_count){
  
  # 1. filtering for NAV and COLLOM
  species_data <- data[data$SPECIES %in% species_to_update, ]
  
  # 2. Apply function to create "new_fruit_count" column
  species_data$new_fruit_count <- sapply(1:nrow(species_data), function(row) calculate_new_fruit_count(row, species_data))
  
  # 3. create "fruits" column using coalesce to combine fruit counts
  species_data <- species_data %>% 
    mutate(fruits = coalesce(new_fruit_count, EXACTFR, TOTALFR))
  
  # 4. remove NAv and COLLOM from og dataset
  data_no_nav_collom <- data[!data$SPECIES %in% species_to_update, ]
  
  # 5. Coalesce "fruits" for the rest of the species 
  data_no_nav_collom <- data_no_nav_collom %>% mutate(fruits = coalesce(EXACTFR, TOTALFR))
  
  # 6. select only relevant columns for merging/want to keep
  columns_to_keep <- c("PLOT", "SPECIES", "PLOT.1", "SUBPLOT", "fruits", "PARK")
  species_data <- species_data %>%  select(all_of(columns_to_keep))
  data_no_nav_collom <- data_no_nav_collom %>% select(all_of(columns_to_keep))
  
  # 7. LAST STEP: combining updated data
  updated_data <- rbind(data_no_nav_collom, species_data)
  
  return(updated_data)
  
}


# function on wir data! 
wir_updated_focals <- update_fruit_counts(wir_focals_dat, nav_and_collom, calculate_new_fruit_count)



```



# RF changing fruit counts
```{r}
###############
### RF -- need to also changing FR1 to TOTAL FR
#############
  # new name = old name
rf_focals_dat <- rf_focals_dat %>% rename(TOTALFR = FR1)
rf_updated_focals <- update_fruit_counts(rf_focals_dat, nav_and_collom, calculate_new_fruit_count)

```

#BR changing fruit counts
```{r}
# modifying TOTAL.FR to TOTALFR for fxn to work
  # new name = old name
br_focals_dat <- br_focals_dat %>% rename(TOTALFR = TOTAL.FR)
br_updated_focals <- update_fruit_counts(br_focals_dat, nav_and_collom, calculate_new_fruit_count)

```


# merging each respective focal df with neighborhood df on plot/subplot
```{r}

# want to merge on all common columns to reduce chances of repeats

merge_neighbor_fitness <- function(focal_data, neighborhood_data){
  
  common_cols <- intersect(colnames(focal_data), colnames(neighborhood_data))
  neighborhood_focal <- merge(neighborhood_data, focal_data, by = c(common_cols))

  return (neighborhood_focal)
  
}

neighborhood_focal_br <- merge_neighbor_fitness(br_updated_focals, br_neighborhoods_data)
neighborhood_focal_rf <- merge_neighbor_fitness(rf_updated_focals, rf_neighborhoods_data)
neighborhood_focal_wir <- merge_neighbor_fitness(wir_updated_focals, wir_neighborhoods_data)


common_cols <- intersect(colnames(sem_focals_dat), colnames(sem_neighborhoods_data))
# print(colnames(sem_focals_dat))
# print(colnames(sem_neighborhoods_data))
# print(common_cols)
  # it's sem_neighbors_filtered bc they had the 'Y' or 'N' focals collect column (the rest of the datasets don't have this so using the og neighborhood data for the rest)
neighborhood_focal_sem <- merge(sem_neighbors_filtered, sem_updated_focals, by = c(common_cols))

```


# dropping/selecting columns we need
## focal species, seeds/fruits, all of the neighbor counts columns (for SEM)
```{r}
# KEEPING A PLOT COLUMN

neighborhood_focal_sem <- neighborhood_focal_sem %>% select(-PARK, -PLOT.1, -SUBPLOT, -`focal collect?`)

# need to alphabetize 
neighborhood_focal_sem <- neighborhood_focal_sem %>% arrange(SPECIES)
# changing SPECIES to focals
neighborhood_focal_sem <- neighborhood_focal_sem %>% rename(focal = SPECIES)
# (not necc correct) BUT changing fruits to seeds
neighborhood_focal_sem <- neighborhood_focal_sem %>% rename(seeds = fruits)

# dropping any rows that dont have a final_fruit_count
neighborhood_focal_sem <- neighborhood_focal_sem %>% filter(!is.na(seeds))

# trying to alphabetize the weed columns while leaving out seeds and focal

# Specify the columns to leave out or move to the front
columns_to_exclude <- c("focal", "seeds", "PLOT")
# Alphabetize the remaining columns
remaining_columns <- setdiff(names(neighborhood_focal_sem), columns_to_exclude)
sorted_columns <- remaining_columns[order(remaining_columns)]
# Combine the specified columns with the sorted columns
new_order <- c(columns_to_exclude, sorted_columns)
# Reorder the data frame
neighborhood_focal_sem <- neighborhood_focal_sem %>% select(all_of(new_order))

# filling any blanks with 0s
neighborhood_focal_sem[neighborhood_focal_sem == ''] <- 0

```


## encapsulating above into a function 
```{r}

clean_neighborhood_focal <- function(data){
  # # cleaning data into final format to match the simul_data from Bimler
  
  # 1. remove unnecessary columns
  if ("`focal collect?`" %in% colnames(data)){
      data <- data %>%
    select(-PLOT.1, -SUBPLOT, -`focal collect?`)
  } else {
    data <- data %>%
      select(-PLOT.1, -SUBPLOT)
             }

  
  # 2. sort by SPECIES column (get into alphabetical order)
  data <- data %>%
    arrange(SPECIES)
  
  # 3. rename SPECIES to focal and fruits to seeds
  data <- data %>%
    rename(focal = SPECIES, seeds = fruits)
  
  # 4. Remove rows without a final fruit count
  data <- data %>%
    filter(!is.na(seeds))
  
  # 5. reorder columns to put focal, seeds, and PLOT at front
  columns_to_exclude <- c("focal", "seeds", "PLOT", "PARK")
  remaining_columns <- setdiff(names(data), columns_to_exclude)
  sorted_columns <- remaining_columns[order(remaining_columns)]
  # Combine the specified columns with the sorted columns
  new_order <- c(columns_to_exclude, sorted_columns)
  # Reorder the data frame
  data <- data %>%
    select(all_of(new_order))
  
  # 6. replace empty cells with 0
  data[data == ''] <- 0
  
  return (data)
}


neighborhood_focal_br <- clean_neighborhood_focal(neighborhood_focal_br)
# for some reason focal collect is still in br, hard-coding for now
neighborhood_focal_br <- neighborhood_focal_br %>%
    select(-`focal collect?`)

neighborhood_focal_wir <- clean_neighborhood_focal(neighborhood_focal_wir)
neighborhood_focal_rf <- clean_neighborhood_focal(neighborhood_focal_rf)
```


# ADDING ALONES
## zeroing out in weeds, seed counts, species
```{r}
all_alones <- read.csv("fitness alone focals(ALL alone focals).csv")
all_alones<- all_alones %>% rename(TOTALFR = fr1)


# doing the fruit count
calculate_new_fruit_count <- function(row, data){
  # calculating the average side and tops in the function?
  
  average_top <- mean(data$TOPFR, na.rm = TRUE)
  average_side <- mean(data$SIDEFR, na.rm = TRUE)
  
  if(!is.na(data[row, 'TOPFR']) & !is.na(data[row, 'SIDEFR'])){
    return(data[row, 'TOPFR'] + ((data[row, "TOTALFR"] - 1) *data[row, 'SIDEFR']))
  }
  else{
    return(average_top + ((data[row, 'TOTALFR'] - 1) * average_side))
  }
}

# only want to apply the function to NAV and COLLOM 
nav_and_collom <- c("NAVSQU", "COLLOM")
nav_and_collom_alone <-  all_alones[all_alones$SPECIES %in% nav_and_collom, ]

# applying function to the filtered nav/collom dataset
nav_and_collom_alone$NEW_FRUIT_COUNT <- sapply(1:nrow(nav_and_collom_alone), function(row) calculate_new_fruit_count(row, nav_and_collom_alone))

# Merge the new column back to the original dataframe
all_alones <- merge(all_alones, nav_and_collom_alone[, c("SPECIES", "NEW_FRUIT_COUNT")], by = "SPECIES", all.x = TRUE)

# merge all of the different fruit counts into one column using coalesce 
all_alones <- all_alones %>% 
  mutate(fruits = coalesce(NEW_FRUIT_COUNT, EXACTFR, TOTALFR))

# getting rid of all columns except for PARK, SPECIES, PLOT, fruits
all_alones <- all_alones %>% select(PARK, SPECIES, PLOT, fruits)

# rename SPECIES to focal and fruits to seeds
all_alones <- all_alones %>%
    rename(focal = SPECIES, seeds = fruits)

```

```{r}
# currently have all of the alone data with PARK, SPECIES, PLOT, and fruits
  # next step is to figure out how to make a function that can merge the right park diverse data with the park's neighborhood data

# need to filter the alones to just be BR
alones_br <- all_alones %>% filter(PARK == "BR")
alones_rf <- all_alones %>% filter(PARK == "RF")
alones_wir <- all_alones %>% filter(PARK == "WIR")


# find columns in diverse park data that are missing in the alones
missing_cols_br <- setdiff(names(neighborhood_focal_br), names(alones_br))
# add missing columns to alones_br, filling with 0s
alones_br[missing_cols_br] <- 0

# find columns in diverse park data that are missing in the alones
missing_cols_rf <- setdiff(names(neighborhood_focal_rf), names(alones_rf))
# add missing columns to alones_br, filling with 0s
alones_rf[missing_cols_rf] <- 0

# find columns in diverse park data that are missing in the alones
missing_cols_wir <- setdiff(names(neighborhood_focal_wir), names(alones_wir))
# add missing columns to alones_br, filling with 0s
alones_wir[missing_cols_wir] <- 0

# finalized datasets
final_BR_data <- rbind(neighborhood_focal_br, alones_br)
final_RF_data <- rbind(neighborhood_focal_rf, alones_rf)
final_WIR_data <- rbind(neighborhood_focal_wir, alones_wir)

# # now filtering for SEM 
# all_alones_sem <- all_alones %>% filter (PARK=="SEM")

```


# finalized datasets
```{r}

cleaning_to_final_dataset <- function(final_data){

  # before saving it as a csv,for stan data we have to replace all nas with 0s!
  # also have to force the doubles to be ints, so also means rounding any decimals
  neighbor_focal_all <- final_data %>%
    mutate_all(~ ifelse(is.na(.), 0, .)) %>%
    mutate_if(is.double, as.integer)
  
  
  return (neighbor_focal_all)

}

rf_final_data <- cleaning_to_final_dataset(final_RF_data)
br_final_data <- cleaning_to_final_dataset(final_BR_data)

# for some reason wir has a "loc" and a "Var.35" column... hardcoding these out for now (11/11)
wir_final_data <- cleaning_to_final_dataset(final_WIR_data)
wir_final_data <- wir_final_data %>%
  select(-loc, -Var.35)
# there is also a single value "skip" hidden in the depths of the wir_final_data 
  # hardcoding this row out 
#   row col
# [1,] 221  25
wir_final_data <- wir_final_data[!apply(wir_final_data == "skip", 1, any), ]


#colnames(wir_final_data)
# double checking
#anyNA(wir_final_data)

# saving it as a csv!
#write.csv(sem_neighbor_focal_all, "sem_neighbor_focal_all_11_10.csv")
# write.csv(rf_final_data, "rf_final_data.csv")
# write.csv(br_final_data, "br_final_data.csv")
#write.csv(wir_final_data, "wir_final_data.csv")

```
