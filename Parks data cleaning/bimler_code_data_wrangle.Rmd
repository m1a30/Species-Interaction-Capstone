---
title: "bimler_code_data_wrangle"
output: html_document
date: "2024-08-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# loading in data
```{r}
library(tidyverse)

wir_focals_dat <- read.csv("focals/wir fitness(WIR diverse focals).csv")
wir_neighborhoods_data <- read.csv("neighborhoods/wir fitness(WIR neighborhoods).csv")

br_focals_dat <- read.csv("focals/br fitness(BR diverse focals).csv")
br_neighborhoods_data <- read.csv("neighborhoods/br fitness(BR neighborhoods).csv")

sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")

rf_focals_dat <- read.csv("focals/riverfront fitness(Riverfront Diverse focals).csv")
rf_neighborhoods_data <- read.csv("neighborhoods/riverfront fitness(RIVERFRONT neighborhoods.csv")

```

# fixing column names for neighborhood data
```{r}
fix_col_names <- function(data){
  #setting column names to values of 1st row
  colnames(data) <- data [1, ]
  
  # removing 1st row
  data <- data[-1,]
  
  return (data)
}

wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
rf_neighborhoods_data <- fix_col_names(rf_neighborhoods_data)
br_neighborhoods_data <- fix_col_names(br_neighborhoods_data)

# filtering the neighborhoods so that we keep only the ones that have focal collects 
  # to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
# wir doesn't have a 'focal collect' column
# rf also doesn't have a 'focal collect' column
# unique(br_neighborhoods_data$`focal collect?`), br focal collect column is just blanks ("")
```

# cleaning the TOPFR and SIDEFR columns' counts into one column
```{r}
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
  # calculating the average side and tops in the function
  
  average_top <- mean(data$TOPFR, na.rm = TRUE)
  average_side <- mean(data$SIDEFR, na.rm = TRUE)
  
  if(!is.na(data[row, 'TOPFR']) & !is.na(data[row, 'SIDEFR'])){
    return((data[row, 'TOPFR']) + ((data[row, "TOTALFR"] - 1) * data[row, 'SIDEFR']))
  }
  else{
    return(average_top + ((data[row, 'TOTALFR'] - 1) * average_side))
  }
}

# only want to apply the function to NAV and COLLOM 
nav_and_collom <- c("NAVSQU", "COLLOM")


```

# SEM fixing fruit counts 
```{r}
###
# modifying TOTAL.FR to TOTALFR for fxn to work
  # new name = old name
sem_focals_dat <- sem_focals_dat %>% rename(TOTALFR = TOTAL.FR)

# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]

# applying function to the filtered nav/collom dataset and creating a column called 'average_fruits'
nav_and_collom_only_sem$average_fruits <- sapply(1:nrow(nav_and_collom_only_sem), function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem))
# this is creating a new column called average_fruits

# JUST FOR NAV AND COLLOM, merging our new values created from the above sapply in the "average_fruits" column with all of the other fruit count columns (just so we're not losing any info...) 
nav_and_collom_only_sem <- nav_and_collom_only_sem %>%
  mutate(fruits = coalesce(average_fruits, EXACTFR, TOTALFR))
#so the new column with all of the fruit counts is now in a column called "fruits"
# but this still keeps all of the columns so there's another column in this dataframe that 

# Merge the new column back to the original dataframe
# removing all nav and collom instances from the main dataframe so that we can merge our newly created fruit counts for ONLY nav and collom back into the larger dataset
sem_focals_dat_no_nav_or_collom <- sem_focals_dat[!(sem_focals_dat$SPECIES %in% c("NAVSQU", "COLLOM")), ]

# coalesce fruits for epiden (EXACTFR) and the rest of the focal species (TOTALFR) into one fruits column
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>%
  mutate(fruits = coalesce(EXACTFR, TOTALFR))


# we are really only interested in the columns: fruits, species, and keeping plot, plot.1, subplot, and park for merging purposes
nav_and_collom_only_sem <- nav_and_collom_only_sem %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)


# now merging the nav_and_collom_only_sem with sem_focals_dat_no_nav_or_collom to get the full dataset!!
sem_updated_focals <- rbind(sem_focals_dat_no_nav_or_collom, nav_and_collom_only_sem)
```



# WIR changing fruit count
```{r}

#working with wir_focals_dat
colnames(wir_focals_dat)
  # for fruits we have TOTALFR = the initial total fruit counts we took at the parks
  # EXACTFR = The EPIDEN fruit counts
  # TOPFR, SIDEFR is the top and side counts for NAVSQU and COLLOM

# attempting to create a function to do everything that I did above

update_fruit_counts <- function(data, species_to_update, calculate_new_fruit_count){
  
  # 1. filtering for NAV and COLLOM
  species_data <- data[data$SPECIES %in% species_to_update, ]
  
  # 2. Apply function to create "average_fruits" column
  species_data$average_fruits <- sapply(1:nrow(species_data), function(row) calculate_new_fruit_count(row, species_data))
  
  # 3. create "fruits" column using coalesce to combine fruit counts
  species_data <- species_data %>% 
    mutate(fruits = coalesce(average_fruits, EXACTFR, TOTALFR))
  
  # 4. remove NAv and COLLOM from og dataset
  data_no_nav_collom <- data[!data$SPECIES %in% species_to_update, ]
  
  # 5. Coalesce "fruits" for the rest of the species
  data_no_nav_collom <- data_no_nav_collom %>% mutate(fruits = coalesce(EXACTFR, TOTALFR))
  
  # 6. select only relevant columns for merging/want to keep
  columns_to_keep <- c("PLOT", "SPECIES", "PLOT.1", "SUBPLOT", "fruits", "PARK")
  species_data <- species_data %>%  select(all_of(columns_to_keep))
  data_no_nav_collom <- data_no_nav_collom %>% select(all_of(columns_to_keep))
  
  # 7. LAST STEP: combining updated data
  updated_data <- rbind(data_no_nav_collom, species_data)
  
  return(updated_data)
  
}


# function on wir data! 
wir_updated_focals <- update_fruit_counts(wir_focals_dat, nav_and_collom, calculate_new_fruit_count)



```



# RF changing fruit counts
```{r}
###############
### RF -- need to also changing FR1 to TOTAL FR
#############
  # new name = old name
rf_focals_dat <- rf_focals_dat %>% rename(TOTALFR = FR1)
rf_updated_focals <- update_fruit_counts(rf_focals_dat, nav_and_collom, calculate_new_fruit_count)

```

#BR changing fruit counts
```{r}
# modifying TOTAL.FR to TOTALFR for fxn to work
  # new name = old name
br_focals_dat <- br_focals_dat %>% rename(TOTALFR = TOTAL.FR)
br_updated_focals <- update_fruit_counts(br_focals_dat, nav_and_collom, calculate_new_fruit_count)

```


# merging each respective focal df with neighborhood df on plot/subplot
```{r}

# want to merge on all common columns to reduce chances of repeats

merge_neighbor_fitness <- function(focal_data, neighborhood_data){
  
  common_cols <- intersect(colnames(focal_data), colnames(neighborhood_data))
  neighborhood_focal <- merge(neighborhood_data, focal_data, by = c(common_cols))

  return (neighborhood_focal)
  
}

neighborhood_focal_br <- merge_neighbor_fitness(br_updated_focals, br_neighborhoods_data)
neighborhood_focal_rf <- merge_neighbor_fitness(rf_updated_focals, rf_neighborhoods_data)
neighborhood_focal_wir <- merge_neighbor_fitness(wir_updated_focals, wir_neighborhoods_data)


# common_cols <- intersect(colnames(sem_focals_dat), colnames(sem_neighborhoods_data))
# print(colnames(sem_focals_dat))
# print(colnames(sem_neighborhoods_data))
# print(common_cols)
  # it's sem_neighbors_filtered bc they had the 'Y' or 'N' focals collect column (the rest of the datasets don't have this so using the og neighborhood data for the rest)
# neighborhood_focal_sem <- merge(sem_neighbors_filtered, sem_updated_focals, by = c(common_cols))

```


# dropping/selecting columns we need
## focal species, seeds/fruits, all of the neighbor counts columns (for SEM)
```{r}
# KEEPING A PLOT COLUMN

neighborhood_focal_sem <- neighborhood_focal_sem %>% select(-PARK, -PLOT.1, -SUBPLOT, -`focal collect?`)

# need to alphabetize 
neighborhood_focal_sem <- neighborhood_focal_sem %>% arrange(SPECIES)
# changing SPECIES to focals
neighborhood_focal_sem <- neighborhood_focal_sem %>% rename(focal = SPECIES)
# (not necc correct) BUT changing fruits to seeds
neighborhood_focal_sem <- neighborhood_focal_sem %>% rename(seeds = fruits)

# dropping any rows that dont have a final_fruit_count
neighborhood_focal_sem <- neighborhood_focal_sem %>% filter(!is.na(seeds))

# trying to alphabetize the weed columns while leaving out seeds and focal

# Specify the columns to leave out or move to the front
columns_to_exclude <- c("focal", "seeds", "PLOT")
# Alphabetize the remaining columns
remaining_columns <- setdiff(names(neighborhood_focal_sem), columns_to_exclude)
sorted_columns <- remaining_columns[order(remaining_columns)]
# Combine the specified columns with the sorted columns
new_order <- c(columns_to_exclude, sorted_columns)
# Reorder the data frame
neighborhood_focal_sem <- neighborhood_focal_sem %>% select(all_of(new_order))

# filling any blanks with 0s
neighborhood_focal_sem[neighborhood_focal_sem == ''] <- 0

```


## encapsulating above into a function 
```{r}

clean_neighborhood_focal <- function(data){
  # # cleaning data into final format to match the simul_data from Bimler
  
  # 1. remove unnecessary columns
  if ("`focal collect?`" %in% colnames(data)){
      data <- data %>%
    select(-PARK, -PLOT.1, -SUBPLOT, -`focal collect?`)
  } else {
    data <- data %>%
      select(-PARK, -PLOT.1, -SUBPLOT)
             }

  
  # 2. sort by SPECIES column (get into alphabetical order)
  data <- data %>%
    arrange(SPECIES)
  
  # 3. rename SPECIES to focal and fruits to seeds
  data <- data %>%
    rename(focal = SPECIES, seeds = fruits)
  
  # 4. Remove rows without a final fruit count
  data <- data %>%
    filter(!is.na(seeds))
  
  # 5. reorder columns to put focal, seeds, and PLOT at front
  columns_to_exclude <- c("focal", "seeds", "PLOT")
  remaining_columns <- setdiff(names(data), columns_to_exclude)
  sorted_columns <- remaining_columns[order(remaining_columns)]
  # Combine the specified columns with the sorted columns
  new_order <- c(columns_to_exclude, sorted_columns)
  # Reorder the data frame
  data <- data %>%
    select(all_of(new_order))
  
  # 6. replace empty cells with 0
  data[data == ''] <- 0
  
  return (data)
}


neighborhood_focal_br <- clean_neighborhood_focal(neighborhood_focal_br)
neighborhood_focal_wir <- clean_neighborhood_focal(neighborhood_focal_wir)
neighborhood_focal_rf <- clean_neighborhood_focal(neighborhood_focal_rf)
```


# ADDING ALONES
## zeroing out in weeds, seed counts, species

# also keep the PLOT column for alones, then for the rest of the entries mark them as diverse?
```{r}
all_alones <- read.csv("fitness alone focals(ALL alone focals).csv")
all_alones<- all_alones %>% rename(TOTALFR = fr1)


# doing the fruit count
calculate_new_fruit_count <- function(row, data){
  # calculating the average side and tops in the function?
  
  average_top <- mean(data$TOPFR, na.rm = TRUE)
  average_side <- mean(data$SIDEFR, na.rm = TRUE)
  
  if(!is.na(data[row, 'TOPFR']) & !is.na(data[row, 'SIDEFR'])){
    return(data[row, 'TOPFR'] + ((data[row, "TOTALFR"] - 1) *data[row, 'SIDEFR']))
  }
  else{
    return(average_top + ((data[row, 'TOTALFR'] - 1) * average_side))
  }
}

# only want to apply the function to NAV and COLLOM 
nav_and_collom <- c("NAVSQU", "COLLOM")
nav_and_collom_alone <-  all_alones[all_alones$SPECIES %in% nav_and_collom, ]

# applying function to the filtered nav/collom dataset
nav_and_collom_alone$NEW_FRUIT_COUNT <- sapply(1:nrow(nav_and_collom_alone), function(row) calculate_new_fruit_count(row, nav_and_collom_alone))

# Merge the new column back to the original dataframe
all_alones <- merge(all_alones, nav_and_collom_alone[, c("SPECIES", "NEW_FRUIT_COUNT")], by = "SPECIES", all.x = TRUE)


# Add missing columns (focals, seeds, and neighbor (weed and focal) species) to all_alones with zeros (for SEM)
missing_cols <- setdiff(names(neighborhood_focal_sem), names(all_alones))
all_alones[missing_cols] <- 0

# coalesce for new_fruit_count, then EXACTFR, then TOTALFR
all_alones <- all_alones %>%
  mutate(FINAL_FRUIT_COUNT = coalesce(NEW_FRUIT_COUNT, EXACTFR, TOTALFR))

# getting rid of columns we don't want 
  # want to keep all neighbor species, fr count, species, and PLOT

all_alones <- all_alones %>% select(-date, -height, -stemcount, -TOTALFR, -fr2, -fr3, -fr4, -fr5, - EXACTFR, -BIOMASS, -TOPFR, -SIDEFR, -notes, -NEW_FRUIT_COUNT, -focal, -seeds)

# now filtering for SEM 
all_alones_sem <- all_alones %>% filter (PARK=="SEM")

# dropping park and rep
all_alones_sem <- all_alones_sem %>% select (-REP, - PARK)

# dropping any rows for now that dont have a final_fruit_count
all_alones_sem <- all_alones_sem %>% filter(!is.na(FINAL_FRUIT_COUNT))


# renaming final_fruit count seeds
# need to alphabetize 
all_alones_sem <- all_alones_sem %>% arrange(SPECIES)
# changing SPECIES to focals
all_alones_sem <- all_alones_sem %>% rename(focal = SPECIES)
# (not necc correct) BUT changing fruits to seeds
all_alones_sem <- all_alones_sem %>% rename(seeds = FINAL_FRUIT_COUNT)

# trying to alphabetize the weed columns while leaving out seeds and focal

# Specify the columns to leave out or move to the front
columns_to_exclude <- c("focal", "seeds", "PLOT")
# Alphabetize the remaining columns
remaining_columns <- setdiff(names(all_alones_sem), columns_to_exclude)
sorted_columns <- remaining_columns[order(remaining_columns)]
# Combine the specified columns with the sorted columns
new_order <- c(columns_to_exclude, sorted_columns)
# Reorder the data frame
all_alones_sem <- all_alones_sem %>% select(all_of(new_order))

```
# SEM finalized dataset
```{r}
sem_neighbor_focal_all <- rbind(neighborhood_focal_sem, all_alones_sem)

# before saving it as a csv,for stan data we have to replace all nas with 0s!
# also have to force the doubles to be ints, so also means rounding any decimals

sem_neighbor_focal_all <- sem_neighbor_focal_all %>%  
  mutate_all(~ ifelse(is.na(.), 0, .)) %>% 
  mutate_if(is.double, as.integer)

# double checking
sapply(sem_neighbor_focal_all, anyNA)
anyNA(sem_neighbor_focal_all)

# saving it as a csv!
#write.csv(sem_neighbor_focal_all, "sem_neighbor_focal_all_11_10.csv")

```
