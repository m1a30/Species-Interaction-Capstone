knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
# wir_focals_dat <- read.csv("focals/wir fitness(WIR diverse focals).csv")
# wir_neighborhoods_data <- read.csv("neighborhoods/wir fitness(WIR neighborhoods).csv")
#
# br_focals_dat <- read.csv("focals/br fitness(BR diverse focals).csv")
# br_neighborhoods_data <- read.csv("neighborhoods/br fitness(BR neighborhoods).csv")
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
# rf_focals_dat <- read.csv("focals/riverfront fitness(Riverfront Diverse focals).csv")
# rf_neighborhoods_data <- read.csv("neighborhoods/riverfront fitness(RIVERFRONT neighborhoods.csv")
fix_col_names <- function(data){
#setting column names to values of 1st row
colnames(data) <- data [1, ]
# removing 1st row
data <- data[-1,]
return (data)
}
#wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
#rf_neighborhoods_data <- fix_col_names(rf_neighborhoods_data)
#br_neighborhoods_data <- fix_col_names(br_neighborhoods_data)
# filtering the neighborhoods so that we keep only the ones that have focal collects
# to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
# wir doesn't have a 'focal collect' column
# rf also doesn't have a 'focal collect' column
# unique(br_neighborhoods_data$`focal collect?`), br focal collect column is just blanks ("")
# 11/19: just realized this is only true for Nav and Collom? Because for the rest of the plants we got, we would've gotten exact counts of fruits?
# TOPFR is number of fruits on the top infloresence
sem_focals_dat <- sem_focals_dat %>%
rename("TOP_INFL_FR" = "TOPFR")
# TOTALFR is the total number of infloresences
sem_focals_dat <- sem_focals_dat %>%
rename("TOTAL_INFL" = "TOTAL.FR")
# SIDEFR is the number of fruits on side infl
sem_focals_dat <- sem_focals_dat %>%
rename("SIDE_INFL_FR" = "SIDEFR")
# TODO: Think about what to do about the rows with special notes like BT, BT no fruits?, couldn't find, BT Fruit gone (leaning towards just dropping these)
#sem_focals_dat[sem_focals_dat$NOTES != "", ]
# would mean dropping 18 rows out of 203 rows
# what are all the unique notes, how many are there
# how many different variations of BT do we have
# "BT", "BT no fruits?", "BT Fruit gone", "BT BAGGED \"11\"?"
# "GONE", "couldn't find", I think these ones can definitely be dropped
# these are looking at the notes/the exact instances of the notes
# unique(sem_focals_dat$NOTES)
# BT_sem <- sem_focals_dat[str_detect(sem_focals_dat$NOTES, "BT"), ]
# GONE_sem <- sem_focals_dat[str_detect(sem_focals_dat$NOTES, "GONE|couldn't find"), ]
# I want to drop all of these, dropping the BT ~10 of these and dropping the GONE/couldn't find rows, ~10 of these
sem_focals_dat <- sem_focals_dat[!str_detect(sem_focals_dat$NOTES, "GONE|couldn't find|BT"), ]
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
# calculating the average side and tops in the function
#TODO: this doesn't differentiate between nav and collomia, it's just taking the
# averages of the entire column (need to make sure it's doing these separately)
# identify species for the row
species <- data[row, "SPECIES"]
# filter data for current species
species_data <- data[data$SPECIES == species, ]
average_top <- mean(species_data$TOP_INFL_FR, na.rm = TRUE)
average_side <- mean(species_data$SIDE_INFL_FR, na.rm = TRUE)
# making sure the averages are correct for each species
print(paste("Processing row:", row,
"| Species:", species,
"| Average TOP_INFL_FR:", round(average_top, 2),
"| Average SIDE_INFL_FR:", round(average_side, 2)))
# Error checking for the specific row
print(paste("Processing row:", row,
"TOTAL_INFL:", data[row, "TOTAL_INFL"],
"TOP_INFL_FR:", data[row, "TOP_INFL_FR"],
"SIDE_INFL_FR:", data[row, "SIDE_INFL_FR"]))
# TODO: need to think of another way to deal with these, there's at least one instance where there is no total infl, but there is a side and/or top infl count
if (is.na(data[row, "TOTAL_INFL"])) {
print(paste("Row", row, "- Skipping because TOTAL_INFL is NA"))
return(NA)
}
# If TOTAL_INFL == 1 and TOP_INFL_FR and SIDE_INFL_FR are present
else if (!is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"]) && (data[row, "TOTAL_INFL"] == 1)) {
print(paste("Row", row, "- Case: TOTAL_INFL == 1"))
return(data[row, "TOP_INFL_FR"] + data[row, "SIDE_INFL_FR"])
}
# If all values are present
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: All values present"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * data[row, "SIDE_INFL_FR"]))
}
# if side_infl and top infl are missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just side infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just top infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# Catch-all for unhandled cases
else {
print(paste("Row", row, "- Case: Unhandled"))
return(NA)
}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
# double checking averages, the function says top: 17.75, side: 2.12
# nav_sem <-  sem_focals_dat[sem_focals_dat$SPECIES =="NAVSQU", ]
# nav_sem_side_mean <- mean(nav_sem$TOP_INFL_FR, na.rm = TRUE)
# nav_sem_top_mean <- mean(nav_sem$SIDE_INFL_FR, na.rm = TRUE)
# collom_sem <-  sem_focals_dat[sem_focals_dat$SPECIES =="COLLOM", ]
# collom_sem_side_mean <- mean(collom_sem$TOP_INFL_FR, na.rm = TRUE)
# collom_sem_top_mean <- mean(collom_sem$SIDE_INFL_FR, na.rm = TRUE)
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset and creating a column called 'new_fruit_count'
nav_and_collom_only_sem$new_fruit_count <- sapply(
1:nrow(nav_and_collom_only_sem),
function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem)
)
# JUST FOR NAV AND COLLOM, merging our new values created from the above sapply in the "new_fruit_count", using coalesce to see if there's new values in new_fruit_count, if not, taking from TOTAL_INFL column
nav_and_collom_only_sem <- nav_and_collom_only_sem %>%
mutate(fruits = coalesce(new_fruit_count, TOTAL_INFL))
#so the new column with all of the fruit counts is now in a column called "fruits"
# Merge the new column back to the original dataframe
# removing all nav and collom instances from the main dataframe so that we can merge our newly created fruit counts for ONLY nav and collom back into the larger dataset
sem_focals_dat_no_nav_or_collom <- sem_focals_dat[!(sem_focals_dat$SPECIES %in% c("NAVSQU", "COLLOM")), ]
# coalesce fruits for epiden (EXACTFR) and the rest of the focal species (TOTAL_INFL) into one fruits column
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>%
mutate(fruits = coalesce(EXACTFR, TOTAL_INFL))
# we are really only interested in the columns: fruits, species, and keeping plot, plot.1, subplot, and park for merging purposes
nav_and_collom_only_sem <- nav_and_collom_only_sem %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
# now merging the nav_and_collom_only_sem with sem_focals_dat_no_nav_or_collom to get the full dataset!!
sem_updated_focals <- rbind(sem_focals_dat_no_nav_or_collom, nav_and_collom_only_sem)
# still have NA values here in the fruits column, there's quite a few just from looking
# Show rows with NA in the 'fruits' column
rows_with_na_fruits <- sem_updated_focals[is.na(sem_updated_focals$fruits), ]
print(rows_with_na_fruits)
# basically all of the NAs are EPIDEN, of 28 na fruit values, there's two collom, 1 navsqu, and 1 gilcap
# TODO: rethinking how to go about getting the epiden fruit values, would an average of the fruit counts we do have be oversimplifying it too much?
sem_epidens <- sem_updated_focals[sem_updated_focals$SPECIES == "EPIDEN" , ]
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$EXACT)
# TODO: for now, just getting rid of all NAs
sem_updated_focals <- na.omit(sem_updated_focals)
sem_epidens
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$fruits)
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$fruits, na.rm = TRUE)
# we have the fruit counts of 8 EPIDEN, out of 32
mean_fruits_sem_epiden <- mean(sem_epidens$fruits, na.rm = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
# wir_focals_dat <- read.csv("focals/wir fitness(WIR diverse focals).csv")
# wir_neighborhoods_data <- read.csv("neighborhoods/wir fitness(WIR neighborhoods).csv")
#
# br_focals_dat <- read.csv("focals/br fitness(BR diverse focals).csv")
# br_neighborhoods_data <- read.csv("neighborhoods/br fitness(BR neighborhoods).csv")
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
# rf_focals_dat <- read.csv("focals/riverfront fitness(Riverfront Diverse focals).csv")
# rf_neighborhoods_data <- read.csv("neighborhoods/riverfront fitness(RIVERFRONT neighborhoods.csv")
fix_col_names <- function(data){
#setting column names to values of 1st row
colnames(data) <- data [1, ]
# removing 1st row
data <- data[-1,]
return (data)
}
#wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
#rf_neighborhoods_data <- fix_col_names(rf_neighborhoods_data)
#br_neighborhoods_data <- fix_col_names(br_neighborhoods_data)
# filtering the neighborhoods so that we keep only the ones that have focal collects
# to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
# wir doesn't have a 'focal collect' column
# rf also doesn't have a 'focal collect' column
# unique(br_neighborhoods_data$`focal collect?`), br focal collect column is just blanks ("")
# TODO: 11/19: just realized this is only true for Nav and Collom? Because for the rest of the plants we got, we would've gotten exact counts of fruits?
# TOPFR is number of fruits on the top infloresence
sem_focals_dat <- sem_focals_dat %>%
rename("TOP_INFL_FR" = "TOPFR")
# TOTALFR is the total number of infloresences
sem_focals_dat <- sem_focals_dat %>%
rename("TOTAL_INFL" = "TOTAL.FR")
# SIDEFR is the number of fruits on side infl
sem_focals_dat <- sem_focals_dat %>%
rename("SIDE_INFL_FR" = "SIDEFR")
# dropping all rows with notes in them (BT/Gone)
sem_focals_dat <- sem_focals_dat[!str_detect(sem_focals_dat$NOTES, "GONE|couldn't find|BT"), ]
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
# identify species for the row
species <- data[row, "SPECIES"]
# filter data for current species
species_data <- data[data$SPECIES == species, ]
# TODO: 11/20 instead of averages, use a linear regression between height and # seeds
average_top <- mean(species_data$TOP_INFL_FR, na.rm = TRUE)
average_side <- mean(species_data$SIDE_INFL_FR, na.rm = TRUE)
# making sure the averages are correct for each species
print(paste("Processing row:", row,
"| Species:", species,
"| Average TOP_INFL_FR:", round(average_top, 2),
"| Average SIDE_INFL_FR:", round(average_side, 2)))
# Error checking for the specific row
print(paste("Processing row:", row,
"TOTAL_INFL:", data[row, "TOTAL_INFL"],
"TOP_INFL_FR:", data[row, "TOP_INFL_FR"],
"SIDE_INFL_FR:", data[row, "SIDE_INFL_FR"]))
if (is.na(data[row, "TOTAL_INFL"])) {
print(paste("Row", row, "- Skipping because TOTAL_INFL is NA"))
return(NA)
}
# If TOTAL_INFL == 1 and TOP_INFL_FR and SIDE_INFL_FR are present
else if (!is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"]) && (data[row, "TOTAL_INFL"] == 1)) {
print(paste("Row", row, "- Case: TOTAL_INFL == 1"))
return(data[row, "TOP_INFL_FR"] + data[row, "SIDE_INFL_FR"])
}
# If all values are present
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: All values present"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * data[row, "SIDE_INFL_FR"]))
}
# if side_infl and top infl are missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just side infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just top infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# Catch-all for unhandled cases
else {
print(paste("Row", row, "- Case: Unhandled"))
return(NA)
}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset and creating a column called 'new_fruit_count'
nav_and_collom_only_sem$new_fruit_count <- sapply(
1:nrow(nav_and_collom_only_sem),
function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem)
)
# JUST FOR NAV AND COLLOM, merging our new values created from the above sapply in the "new_fruit_count", using coalesce to see if there's new values in new_fruit_count, if not, taking from TOTAL_INFL column
nav_and_collom_only_sem <- nav_and_collom_only_sem %>%
mutate(fruits = coalesce(new_fruit_count, TOTAL_INFL))
#so the new column with all of the fruit counts is now in a column called "fruits"
# Merge the new column back to the original dataframe
# removing all nav and collom instances from the main dataframe so that we can merge our newly created fruit counts for ONLY nav and collom back into the larger dataset
sem_focals_dat_no_nav_or_collom <- sem_focals_dat[!(sem_focals_dat$SPECIES %in% c("NAVSQU", "COLLOM")), ]
# coalesce fruits for epiden (EXACTFR) and the rest of the focal species (TOTAL_INFL) into one fruits column
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>%
mutate(fruits = coalesce(EXACTFR, TOTAL_INFL))
# we are really only interested in the columns: fruits, species, and keeping plot, plot.1, subplot, and park for merging purposes
nav_and_collom_only_sem <- nav_and_collom_only_sem %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
# now merging the nav_and_collom_only_sem with sem_focals_dat_no_nav_or_collom to get the full dataset!!
sem_updated_focals <- rbind(sem_focals_dat_no_nav_or_collom, nav_and_collom_only_sem)
# still have NA values here in the fruits column, there's quite a few just from looking
# Show rows with NA in the 'fruits' column
rows_with_na_fruits <- sem_updated_focals[is.na(sem_updated_focals$fruits), ]
print(rows_with_na_fruits)
# basically all of the NAs are EPIDEN, of 28 na fruit values, there's 2 collom, 1 navsqu, and 1 gilcap
# TODO: rethinking how to go about getting the epiden fruit values, would an average of the fruit counts we do have be oversimplifying it too much?
sem_epidens <- sem_updated_focals[sem_updated_focals$SPECIES == "EPIDEN" , ]
# TODO: for now, just getting rid of all NAs
sem_updated_focals <- na.omit(sem_updated_focals)
sem_epidens
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$fruits)
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$fruits, na.rm = TRUE)
# we have the fruit counts of 8 EPIDEN, out of 32
mean_fruits_sem_epiden <- mean(sem_epidens$fruits, na.rm = TRUE)
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
head(sem_focals_dat)
head(sem_focals_dat); dim(sem_focals_dat)
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
head(sem_neighborhoods_data); dim(sem_neighborhoods_data)
sem_neighborhoods_data <- read.csv("neighborhoods/sem neighborhoods.csv")
head(sem_neighborhoods_data); dim(sem_neighborhoods_data)
sem_focals_dat <- read.csv("data_raw/sem focals.csv")
sem_neighborhoods_data <- read.csv("data_raw/sem neighborhoods.csv")
head(sem_focals_dat); dim(sem_focals_dat)
head(sem_neighborhoods_data); dim(sem_neighborhoods_data)
head(sem_focals_dat,2); dim(sem_focals_dat)
head(sem_neighborhoods_data,2); dim(sem_neighborhoods_data)
sem_neighborhoods_data <- read.csv("data_raw/sem neighborhoods.csv")
sem_focals <- read.csv("data_raw/sem focals.csv")
sem_neighborhoods <- read.csv("data_raw/sem neighborhoods.csv")
table(sem_neighborhoods_data$focal_collect)
sem_focals <- read.csv("data_raw/sem focals.csv")
sem_neighborhoods <- read.csv("data_raw/sem neighborhoods.csv")
head(sem_focals,2); dim(sem_focals_dat)
head(sem_neighborhoods,2); dim(sem_neighborhoods_data)
head(sem_focals,2); dim(sem_focals)
head(sem_neighborhoods,2); dim(sem_neighborhoods)
table(sem_neighborhoods$focal_collect)
sem_focals <- read.csv("data_raw/sem focals.csv", na.strings=c("NA","NaN", " ")
)
sem_neighborhoods <- read.csv("data_raw/sem neighborhoods.csv", na.strings=c("NA","NaN", " "))
head(sem_focals,2); dim(sem_focals)
head(sem_neighborhoods,2); dim(sem_neighborhoods)
head(sem_focals,2); dim(sem_focals)
head(sem_neighborhoods,2); dim(sem_neighborhoods)
sem_focals <- read.csv("data_raw/sem focals.csv", na.strings=c("NA","NaN", " ", "") )
head(sem_focals,2); dim(sem_focals)
