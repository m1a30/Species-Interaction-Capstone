```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE)
knitr::opts_chunk$set(fig.width=12, fig.height=8)
library(tidyverse)
library(tidyverse)
library(deSolve)
# we have to feed the ODE solver a set of formulas with independent variable t, dependent variable(s) y, and a set of parameters
predpreyLV <- function(t, y, params){
H <- y[1] # y[1] is the population size of the prey
P <- y[2] # y[2] is the population size of the predator
with(as.list(params), {
dH.dt <- b*H - a*P*H
dP.dt <- e*a*P*H - s*P
return(list(c(dH.dt, dP.dt)))
})
}
params1 <- c(b = 0.5, a = 0.01, s = 0.1, e = 0.2)
Time <- seq(0, 200, by = 0.1)
LV.out <- as.data.frame(ode(c(H0 = 25, P0 = 5), Time, predpreyLV, params1))
LV.out_long <- pivot_longer(LV.out, !time, names_to="species", values_to = "pop_size") #makes plotting a bit easier in ggplot
ggplot(data=LV.out_long, aes(x=time, y=pop_size, color=species))+
geom_line(size = 2) + theme_classic(base_size = 15) + xlab("Time") + ylab("Population Size") +
scale_color_manual(values = c("#820263", "#FFF275"), name = "Species", labels = c("Prey", "Predator"))
ggplot(data = LV.out, aes(x = H0, y = P0)) + geom_path(size = 2) + theme_classic(base_size = 15) + xlab("Prey Population Size") + ylab("Predator Population Size")
lv_plot <- function(b, a, s, e, H0, P0, tmax = 200, tstep = 0.1){
predpreyLV <- function(t, y, params){
H <- y[1] # y[1] is the population size of the prey
P <- y[2] # y[2] is the population size of the predator
with(as.list(params), {
dH.dt <- b*H - a*P*H
dP.dt <- e*a*P*H - s*P
return(list(c(dH.dt, dP.dt)))
})
}
params1 <- c(b = b, a = a, s = s, e = e)
Time <- seq(0, tmax, by = tstep)
LV.out <- as.data.frame(ode(c(H0 = H0, P0 = P0), Time, predpreyLV, params1))
LV.out_long <- pivot_longer(LV.out, !time, names_to="species", values_to = "pop_size")
ggplot(data=LV.out_long, aes(x=time, y=pop_size, color=species))+
geom_line(size = 2) + theme_classic(base_size = 15) + xlab("Time") + ylab("Population Size") +
scale_color_manual(values = c("#820263", "#FFF275"), name = "Species", labels = c("Prey", "Predator"))
}
lv_phase_plot <- function(b, a, s, e, H0, P0, tmax = 200, tstep = 0.1){
predpreyLV <- function(t, y, params){
H <- y[1] # y[1] is the population size of the prey
P <- y[2] # y[2] is the population size of the predator
with(as.list(params), {
dH.dt <- b*H - a*P*H
dP.dt <- e*a*P*H - s*P
return(list(c(dH.dt, dP.dt)))
})
}
params1 <- c(b = b, a = a, s = s, e = e)
Time <- seq(0, tmax, by = tstep)
LV.out <- as.data.frame(ode(c(H0 = H0, P0 = P0), Time, predpreyLV, params1))
ggplot(data = LV.out, aes(x = H0, y = P0)) + geom_path(size = 2) + theme_classic(base_size = 15) + xlab("Prey Population Size") + ylab("Predator Population Size")
}
'hello'
# A numeric
2.4
## an integer
num_candles <- 14
## an integer
num_candles <- 14
favorite_state <- "oregon"
# A numeric
2.4
# A character
"hello"
'hello'
## an integer
num_candles <- 14
## a character
favorite_state <- "oregon"
# Print the different variables
# Print the different variables
num_candles
favorite_state
## an integer
num_candles <- 14
## a character
favorite_state <- "oregon"
# Print the different variables
num_candles
favorite_state
class(favorite_state)
r <- 0.6
K <- 100
n0 <- 10
r <- 0.6
K <- 100
n0 <- 10
## class of an object
class(K)
## round a numeric
round(14.5)
?round
## change a decimal number to an integer
round(14.5555555, digits = 2)
## Paste together characters and integers
print(paste("hello", 4, "student"))
## Paste together characters and integers
paste("hello", 4, "student")
# Standard math operators work as expected on numbers
# Assign some variable to numbers
x <- 4
y <- 6
# Addition
add <- x + y
# Look at the following function
?glmer.nb
?round
round(4.567, digits=1)
# Install the package
#install.packages("lme4") # has quotes
library(lme4)  # does not need to have quotes
?glmer.nb
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
getwd()
setwd("/../Desktop/capstone/JointModelFramework-master/1.code")
setwd("/..")
getwd()
setwd(..)
setwd("~")
getwd()
setwd("/Desktop/capstone/JointModelFramework-master/1.code)
setwd("/Desktop/capstone/JointModelFramework-master/1.code")
setwd("\Desktop/capstone/JointModelFramework-master/1.code")
setwd("Desktop/capstone/JointModelFramework-master/1.code")
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
# instead of the simul_data, want our cleaned dataframe
# source('simul_data.R')  (don't need for running own data)
# instead of simdat, usingobserved values
# all of this below is for the sem data ()
# this is the more simple version of the code, is only the diverse values
# ! TODO: double check how I created this dataframe ----
# load raw data----
sem_data <- read.csv("../Parks data cleaning/only_diverse_sem.csv")
setwd("../")
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
getwd()
setwd("code.1")
setwd("/code.1")
setwd("1.code")
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
# instead of the simul_data, want our cleaned dataframe
# source('simul_data.R')  (don't need for running own data)
# instead of simdat, usingobserved values
# all of this below is for the sem data ()
# this is the more simple version of the code, is only the diverse values
# ! TODO: double check how I created this dataframe ----
# load raw data----
sem_data <- read.csv("../Parks\\ data\\ cleaning/only_diverse_sem.csv")
list.files("../Parks data cleaning/")
# load raw data----
sem_data <- read.csv("../Parks_data_cleaning/only_diverse_sem.csv")
# load raw data----
sem_data <- read.csv("../Parks data cleaning/only_diverse_sem.csv")
# load raw data----
sem_data <- read.csv("../Parks_data_cleaning/only_diverse_sem.csv")
setwd(..)
setwd("..")
sem_data <- read.csv("Parks_data_cleaning/only_diverse_sem.csv")
setwd("Parks_data_cleaning")
# load raw data----
# having trouble with file path
setwd("..")
setwd("Parks_data_cleaning")
sem_data <- read.csv("only_diverse_sem.csv")
