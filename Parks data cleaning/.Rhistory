```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE)
knitr::opts_chunk$set(fig.width=12, fig.height=8)
library(tidyverse)
library(tidyverse)
library(deSolve)
# we have to feed the ODE solver a set of formulas with independent variable t, dependent variable(s) y, and a set of parameters
predpreyLV <- function(t, y, params){
H <- y[1] # y[1] is the population size of the prey
P <- y[2] # y[2] is the population size of the predator
with(as.list(params), {
dH.dt <- b*H - a*P*H
dP.dt <- e*a*P*H - s*P
return(list(c(dH.dt, dP.dt)))
})
}
params1 <- c(b = 0.5, a = 0.01, s = 0.1, e = 0.2)
Time <- seq(0, 200, by = 0.1)
LV.out <- as.data.frame(ode(c(H0 = 25, P0 = 5), Time, predpreyLV, params1))
LV.out_long <- pivot_longer(LV.out, !time, names_to="species", values_to = "pop_size") #makes plotting a bit easier in ggplot
ggplot(data=LV.out_long, aes(x=time, y=pop_size, color=species))+
geom_line(size = 2) + theme_classic(base_size = 15) + xlab("Time") + ylab("Population Size") +
scale_color_manual(values = c("#820263", "#FFF275"), name = "Species", labels = c("Prey", "Predator"))
ggplot(data = LV.out, aes(x = H0, y = P0)) + geom_path(size = 2) + theme_classic(base_size = 15) + xlab("Prey Population Size") + ylab("Predator Population Size")
lv_plot <- function(b, a, s, e, H0, P0, tmax = 200, tstep = 0.1){
predpreyLV <- function(t, y, params){
H <- y[1] # y[1] is the population size of the prey
P <- y[2] # y[2] is the population size of the predator
with(as.list(params), {
dH.dt <- b*H - a*P*H
dP.dt <- e*a*P*H - s*P
return(list(c(dH.dt, dP.dt)))
})
}
params1 <- c(b = b, a = a, s = s, e = e)
Time <- seq(0, tmax, by = tstep)
LV.out <- as.data.frame(ode(c(H0 = H0, P0 = P0), Time, predpreyLV, params1))
LV.out_long <- pivot_longer(LV.out, !time, names_to="species", values_to = "pop_size")
ggplot(data=LV.out_long, aes(x=time, y=pop_size, color=species))+
geom_line(size = 2) + theme_classic(base_size = 15) + xlab("Time") + ylab("Population Size") +
scale_color_manual(values = c("#820263", "#FFF275"), name = "Species", labels = c("Prey", "Predator"))
}
lv_phase_plot <- function(b, a, s, e, H0, P0, tmax = 200, tstep = 0.1){
predpreyLV <- function(t, y, params){
H <- y[1] # y[1] is the population size of the prey
P <- y[2] # y[2] is the population size of the predator
with(as.list(params), {
dH.dt <- b*H - a*P*H
dP.dt <- e*a*P*H - s*P
return(list(c(dH.dt, dP.dt)))
})
}
params1 <- c(b = b, a = a, s = s, e = e)
Time <- seq(0, tmax, by = tstep)
LV.out <- as.data.frame(ode(c(H0 = H0, P0 = P0), Time, predpreyLV, params1))
ggplot(data = LV.out, aes(x = H0, y = P0)) + geom_path(size = 2) + theme_classic(base_size = 15) + xlab("Prey Population Size") + ylab("Predator Population Size")
}
'hello'
# A numeric
2.4
## an integer
num_candles <- 14
## an integer
num_candles <- 14
favorite_state <- "oregon"
# A numeric
2.4
# A character
"hello"
'hello'
## an integer
num_candles <- 14
## a character
favorite_state <- "oregon"
# Print the different variables
# Print the different variables
num_candles
favorite_state
## an integer
num_candles <- 14
## a character
favorite_state <- "oregon"
# Print the different variables
num_candles
favorite_state
class(favorite_state)
r <- 0.6
K <- 100
n0 <- 10
r <- 0.6
K <- 100
n0 <- 10
## class of an object
class(K)
## round a numeric
round(14.5)
?round
## change a decimal number to an integer
round(14.5555555, digits = 2)
## Paste together characters and integers
print(paste("hello", 4, "student"))
## Paste together characters and integers
paste("hello", 4, "student")
# Standard math operators work as expected on numbers
# Assign some variable to numbers
x <- 4
y <- 6
# Addition
add <- x + y
# Look at the following function
?glmer.nb
?round
round(4.567, digits=1)
# Install the package
#install.packages("lme4") # has quotes
library(lme4)  # does not need to have quotes
?glmer.nb
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
getwd()
setwd("/../Desktop/capstone/JointModelFramework-master/1.code")
setwd("/..")
getwd()
setwd(..)
setwd("~")
getwd()
setwd("/Desktop/capstone/JointModelFramework-master/1.code)
setwd("/Desktop/capstone/JointModelFramework-master/1.code")
setwd("\Desktop/capstone/JointModelFramework-master/1.code")
setwd("Desktop/capstone/JointModelFramework-master/1.code")
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
# instead of the simul_data, want our cleaned dataframe
# source('simul_data.R')  (don't need for running own data)
# instead of simdat, usingobserved values
# all of this below is for the sem data ()
# this is the more simple version of the code, is only the diverse values
# ! TODO: double check how I created this dataframe ----
# load raw data----
sem_data <- read.csv("../Parks data cleaning/only_diverse_sem.csv")
setwd("../")
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
getwd()
setwd("code.1")
setwd("/code.1")
setwd("1.code")
getwd()
# Running the joint model on simulated data
# set up R environment ----
require(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#rstan_options(auto_write = TRUE)
library(tidybayes)
library(bayesplot)
library(tidyverse)
library(rethinking)
#install.packages("reshape2")
library(reshape2)
# load required functions
source('data_prep.R')
# instead of the simul_data, want our cleaned dataframe
# source('simul_data.R')  (don't need for running own data)
# instead of simdat, usingobserved values
# all of this below is for the sem data ()
# this is the more simple version of the code, is only the diverse values
# ! TODO: double check how I created this dataframe ----
# load raw data----
sem_data <- read.csv("../Parks\\ data\\ cleaning/only_diverse_sem.csv")
list.files("../Parks data cleaning/")
# load raw data----
sem_data <- read.csv("../Parks_data_cleaning/only_diverse_sem.csv")
# load raw data----
sem_data <- read.csv("../Parks data cleaning/only_diverse_sem.csv")
# load raw data----
sem_data <- read.csv("../Parks_data_cleaning/only_diverse_sem.csv")
setwd(..)
setwd("..")
sem_data <- read.csv("Parks_data_cleaning/only_diverse_sem.csv")
setwd("Parks_data_cleaning")
# load raw data----
# having trouble with file path
setwd("..")
setwd("Parks_data_cleaning")
sem_data <- read.csv("only_diverse_sem.csv")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
wir_focals_dat <- read.csv("focals/wir fitness(WIR diverse focals).csv")
wir_neighborhoods_data <- read.csv("neighborhoods/wir fitness(WIR neighborhoods).csv")
br_focals_dat <- read.csv("focals/br fitness(BR diverse focals).csv")
br_neighborhoods_data <- read.csv("neighborhoods/br fitness(BR neighborhoods).csv")
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
rf_focals_dat <- read.csv("focals/riverfront fitness(Riverfront Diverse focals).csv")
rf_neighborhoods_data <- read.csv("neighborhoods/riverfront fitness(RIVERFRONT neighborhoods.csv")
fix_col_names <- function(data){
#setting column names to values of 1st row
colnames(data) <- data [1, ]
# removing 1st row
data <- data[-1,]
return (data)
}
wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
rf_neighborhoods_data <- fix_col_names(rf_neighborhoods_data)
br_neighborhoods_data <- fix_col_names(br_neighborhoods_data)
# filtering the neighborhoods so that we keep only the ones that have focal collects
# to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
# wir doesn't have a 'focal collect' column
# rf also doesn't have a 'focal collect' column
# unique(br_neighborhoods_data$`focal collect?`), br focal collect column is just blanks ("")
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
# calculating the average side and tops in the function
average_top <- mean(data$TOPFR, na.rm = TRUE)
average_side <- mean(data$SIDEFR, na.rm = TRUE)
if(!is.na(data[row, 'TOPFR']) & !is.na(data[row, 'SIDEFR'])){
return((data[row, 'TOPFR']) + ((data[row, "TOTALFR"] - 1) * data[row, 'SIDEFR']))
}
else{
return(average_top + ((data[row, 'TOTALFR'] - 1) * average_side))
}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
###
# modifying TOTAL.FR to TOTALFR for fxn to work
# new name = old name
sem_focals_dat <- sem_focals_dat %>% rename(TOTALFR = TOTAL.FR)
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset and creating a column called 'average_fruits'
nav_and_collom_only_sem$average_fruits <- sapply(1:nrow(nav_and_collom_only_sem), function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem))
# this is creating a new column called average_fruits
# JUST FOR NAV AND COLLOM, merging our new values created from the above sapply in the "average_fruits" column with all of the other fruit count columns (just so we're not losing any info...)
nav_and_collom_only_sem <- nav_and_collom_only_sem %>%
mutate(fruits = coalesce(average_fruits, EXACTFR, TOTALFR))
#so the new column with all of the fruit counts is now in a column called "fruits"
# but this still keeps all of the columns so there's another column in this dataframe that
# Merge the new column back to the original dataframe
# removing all nav and collom instances from the main dataframe so that we can merge our newly created fruit counts for ONLY nav and collom back into the larger dataset
sem_focals_dat_no_nav_or_collom <- sem_focals_dat[!(sem_focals_dat$SPECIES %in% c("NAVSQU", "COLLOM")), ]
# coalesce fruits for epiden (EXACTFR) and the rest of the focal species (TOTALFR) into one fruits column
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>%
mutate(fruits = coalesce(EXACTFR, TOTALFR))
# we are really only interested in the columns: fruits, species, and keeping plot, plot.1, subplot, and park for merging purposes
nav_and_collom_only_sem <- nav_and_collom_only_sem %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
# now merging the nav_and_collom_only_sem with sem_focals_dat_no_nav_or_collom to get the full dataset!!
sem_updated_focals <- rbind(sem_focals_dat_no_nav_or_collom, nav_and_collom_only_sem)
#working with wir_focals_dat
colnames(wir_focals_dat)
# for fruits we have TOTALFR = the initial total fruit counts we took at the parks
# EXACTFR = The EPIDEN fruit counts
# TOPFR, SIDEFR is the top and side counts for NAVSQU and COLLOM
# attempting to create a function to do everything that I did above
update_fruit_counts <- function(data, species_to_update, calculate_new_fruit_count){
# 1. filtering for NAV and COLLOM
species_data <- data[data$SPECIES %in% species_to_update, ]
# 2. Apply function to create "average_fruits" column
species_data$average_fruits <- sapply(1:nrow(species_data), function(row) calculate_new_fruit_count(row, species_data))
# 3. create "fruits" column using coalesce to combine fruit counts
species_data <- species_data %>%
mutate(fruits = coalesce(average_fruits, EXACTFR, TOTALFR))
# 4. remove NAv and COLLOM from og dataset
data_no_nav_collom <- data[!data$SPECIES %in% species_to_update, ]
# 5. Coalesce "fruits" for the rest of the species
data_no_nav_collom <- data_no_nav_collom %>% mutate(fruits = coalesce(EXACTFR, TOTALFR))
# 6. select only relevant columns for merging/want to keep
columns_to_keep <- c("PLOT", "SPECIES", "PLOT.1", "SUBPLOT", "fruits", "PARK")
species_data <- species_data %>%  select(all_of(columns_to_keep))
data_no_nav_collom <- data_no_nav_collom %>% select(all_of(columns_to_keep))
# 7. LAST STEP: combining updated data
updated_data <- rbind(data_no_nav_collom, species_data)
return(updated_data)
}
# function on wir data!
wir_updated_focals <- update_fruit_counts(wir_focals_dat, nav_and_collom, calculate_new_fruit_count)
###############
### RF -- need to also changing FR1 to TOTAL FR
#############
# new name = old name
rf_focals_dat <- rf_focals_dat %>% rename(TOTALFR = FR1)
rf_updated_focals <- update_fruit_counts(rf_focals_dat, nav_and_collom, calculate_new_fruit_count)
# modifying TOTAL.FR to TOTALFR for fxn to work
# new name = old name
br_focals_dat <- br_focals_dat %>% rename(TOTALFR = TOTAL.FR)
br_updated_focals <- update_fruit_counts(br_focals_dat, nav_and_collom, calculate_new_fruit_count)
# want to merge on all common columns to reduce chances of repeats
merge_neighbor_fitness <- function(focal_data, neighborhood_data){
common_cols <- intersect(colnames(focal_data), colnames(neighborhood_data))
neighborhood_focal <- merge(neighborhood_data, focal_data, by = c(common_cols))
return (neighborhood_focal)
}
neighborhood_focal_br <- merge_neighbor_fitness(br_updated_focals, br_neighborhoods_data)
neighborhood_focal_rf <- merge_neighbor_fitness(rf_updated_focals, rf_neighborhoods_data)
neighborhood_focal_wir <- merge_neighbor_fitness(wir_updated_focals, wir_neighborhoods_data)
common_cols <- intersect(colnames(sem_focals_dat), colnames(sem_neighborhoods_data))
# print(colnames(sem_focals_dat))
# print(colnames(sem_neighborhoods_data))
# print(common_cols)
# it's sem_neighbors_filtered bc they had the 'Y' or 'N' focals collect column (the rest of the datasets don't have this so using the og neighborhood data for the rest)
neighborhood_focal_sem <- merge(sem_neighbors_filtered, sem_updated_focals, by = c(common_cols))
# KEEPING A PLOT COLUMN
neighborhood_focal_sem <- neighborhood_focal_sem %>% select(-PARK, -PLOT.1, -SUBPLOT, -`focal collect?`)
# need to alphabetize
neighborhood_focal_sem <- neighborhood_focal_sem %>% arrange(SPECIES)
# changing SPECIES to focals
neighborhood_focal_sem <- neighborhood_focal_sem %>% rename(focal = SPECIES)
# (not necc correct) BUT changing fruits to seeds
neighborhood_focal_sem <- neighborhood_focal_sem %>% rename(seeds = fruits)
# dropping any rows that dont have a final_fruit_count
neighborhood_focal_sem <- neighborhood_focal_sem %>% filter(!is.na(seeds))
# trying to alphabetize the weed columns while leaving out seeds and focal
# Specify the columns to leave out or move to the front
columns_to_exclude <- c("focal", "seeds", "PLOT")
# Alphabetize the remaining columns
remaining_columns <- setdiff(names(neighborhood_focal_sem), columns_to_exclude)
sorted_columns <- remaining_columns[order(remaining_columns)]
# Combine the specified columns with the sorted columns
new_order <- c(columns_to_exclude, sorted_columns)
# Reorder the data frame
neighborhood_focal_sem <- neighborhood_focal_sem %>% select(all_of(new_order))
# filling any blanks with 0s
neighborhood_focal_sem[neighborhood_focal_sem == ''] <- 0
clean_neighborhood_focal <- function(data){
# # cleaning data into final format to match the simul_data from Bimler
# 1. remove unnecessary columns
if ("`focal collect?`" %in% colnames(data)){
data <- data %>%
select(-PARK, -PLOT.1, -SUBPLOT, -`focal collect?`)
} else {
data <- data %>%
select(-PARK, -PLOT.1, -SUBPLOT)
}
# 2. sort by SPECIES column (get into alphabetical order)
data <- data %>%
arrange(SPECIES)
# 3. rename SPECIES to focal and fruits to seeds
data <- data %>%
rename(focal = SPECIES, seeds = fruits)
# 4. Remove rows without a final fruit count
data <- data %>%
filter(!is.na(seeds))
# 5. reorder columns to put focal, seeds, and PLOT at front
columns_to_exclude <- c("focal", "seeds", "PLOT")
remaining_columns <- setdiff(names(data), columns_to_exclude)
sorted_columns <- remaining_columns[order(remaining_columns)]
# Combine the specified columns with the sorted columns
new_order <- c(columns_to_exclude, sorted_columns)
# Reorder the data frame
data <- data %>%
select(all_of(new_order))
# 6. replace empty cells with 0
data[data == ''] <- 0
return (data)
}
neighborhood_focal_br <- clean_neighborhood_focal(neighborhood_focal_br)
neighborhood_focal_wir <- clean_neighborhood_focal(neighborhood_focal_wir)
neighborhood_focal_rf <- clean_neighborhood_focal(neighborhood_focal_rf)
all_alones <- read.csv("fitness alone focals(ALL alone focals).csv")
all_alones
all_alones<- all_alones %>% rename(TOTALFR = fr1)
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
# calculating the average side and tops in the function?
average_top <- mean(data$TOPFR, na.rm = TRUE)
average_side <- mean(data$SIDEFR, na.rm = TRUE)
if(!is.na(data[row, 'TOPFR']) & !is.na(data[row, 'SIDEFR'])){
return(data[row, 'TOPFR'] + ((data[row, "TOTALFR"] - 1) *data[row, 'SIDEFR']))
}
else{
return(average_top + ((data[row, 'TOTALFR'] - 1) * average_side))
}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
nav_and_collom_alone <-  all_alones[all_alones$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset
nav_and_collom_alone$NEW_FRUIT_COUNT <- sapply(1:nrow(nav_and_collom_alone), function(row) calculate_new_fruit_count(row, nav_and_collom_alone))
# Merge the new column back to the original dataframe
all_alones <- merge(all_alones, nav_and_collom_alone[, c("SPECIES", "NEW_FRUIT_COUNT")], by = "SPECIES", all.x = TRUE)
all_alones
# creating function to filter out the correct weed species for each park
filtering_weeds_each_park <- function(diverse_park_data){
# Add missing columns (focals, seeds, and neighbor (weed and focal) species) to all_alones with zeros (for SEM)
missing_cols <- setdiff(names(diverse_park_data), names(all_alones))
all_alones[missing_cols] <- 0
# coalesce for new_fruit_count, then EXACTFR, then TOTALFR
all_alones <- all_alones %>%
mutate(FINAL_FRUIT_COUNT = coalesce(NEW_FRUIT_COUNT, EXACTFR, TOTALFR))
# getting rid of columns we don't want
# want to keep all neighbor species, fr count, species, and PLOT
all_alones <- all_alones %>% select(-date, -height, -stemcount, -TOTALFR, -fr2, -fr3, -fr4, -fr5, - EXACTFR, -BIOMASS, -TOPFR, -SIDEFR, -notes, -NEW_FRUIT_COUNT, -focal, -seeds)
return (all_alones)
}
# merge all of the different fruit counts into one column using coalesce
all_alones <- all_alones %>%
mutate(fruits = coalesce(NEW_FRUIT_COUNT, EXACTFR, TOTALFR))
all_alones
# getting rid of all columns except for PARK, SPECIES, PLOT, fruits
all_alones <- all_alones %>% select(PARK, SPECIES, PLOT, fruits)
all_alones
neighborhood_focal_br
