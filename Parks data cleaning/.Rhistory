}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset and creating a column called 'new_fruit_count'
nav_and_collom_only_sem$new_fruit_count <- sapply(1:nrow(nav_and_collom_only_sem), function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem))
# JUST FOR NAV AND COLLOM, merging our new values created from the above sapply in the "new_fruit_count", using coalesce to see if there's new values in new_fruit_count, if not, taking from TOTAL_INFL column
nav_and_collom_only_sem <- nav_and_collom_only_sem %>%
mutate(fruits = coalesce(new_fruit_count, TOTAL_INFL))
#so the new column with all of the fruit counts is now in a column called "fruits"
# Merge the new column back to the original dataframe
# removing all nav and collom instances from the main dataframe so that we can merge our newly created fruit counts for ONLY nav and collom back into the larger dataset
sem_focals_dat_no_nav_or_collom <- sem_focals_dat[!(sem_focals_dat$SPECIES %in% c("NAVSQU", "COLLOM")), ]
# coalesce fruits for epiden (EXACTFR) and the rest of the focal species (TOTAL_INFL) into one fruits column
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>%
mutate(fruits = coalesce(EXACTFR, TOTAL_INFL))
# we are really only interested in the columns: fruits, species, and keeping plot, plot.1, subplot, and park for merging purposes
nav_and_collom_only_sem <- nav_and_collom_only_sem %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
# now merging the nav_and_collom_only_sem with sem_focals_dat_no_nav_or_collom to get the full dataset!!
sem_updated_focals <- rbind(sem_focals_dat_no_nav_or_collom, nav_and_collom_only_sem)
# still have NA values here in the fruits column, there's quite a few just from looking
# Show rows with NA in the 'fruits' column
rows_with_na_fruits <- sem_updated_focals[is.na(sem_updated_focals$fruits), ]
print(rows_with_na_fruits)
# basically all of the NAs are EPIDEN, of 28 na fruit values, there's two collom, 1 navsqu, and 1 gilcap
# TODO: rethinking how to go about getting the epiden fruit values, would an average of the fruit counts we do have be oversimplifying it too much?
sem_epidens <- sem_updated_focals[sem_updated_focals$SPECIES == "EPIDEN" , ]
# we have the fruit counts of 8 EPIDEN, out of 32
# TODO: for now, just getting rid of all NAs
sem_updated_focals <- na.omit(sem_updated_focals)
all_alones <- read.csv("fitness alone focals(ALL alone focals).csv")
# will generally either want fr1 or EXACTFR as TOTALFR, use coalesce to check if there's an EXACTFR value, if not use the fr1 as TOTALFR
all_alones <- all_alones %>%
mutate(TOTALFR = coalesce(EXACTFR, fr1))
colnames(all_alones)
# TODO: think through the column name changes
# TOPFR is number of fruits on the top infloresence
all_alones <- all_alones %>%
rename("TOP_INFL_FR" = "TOPFR")
# TOTALFR is the total number of infloresences
all_alones <- all_alones %>%
rename("TOTAL_INFL" = "TOTALFR")
# SIDEFR is the all_alones of fruits on side infl
all_alones <- all_alones %>%
rename("SIDE_INFL_FR" = "SIDEFR")
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
nav_and_collom_alone <-  all_alones[all_alones$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset
nav_and_collom_alone$NEW_FRUIT_COUNT <- sapply(1:nrow(nav_and_collom_alone), function(row) calculate_new_fruit_count(row, nav_and_collom_alone))
# Merge the new column back to the original dataframe
all_alones <- merge(all_alones, nav_and_collom_alone[, c("SPECIES", "NEW_FRUIT_COUNT")], by = "SPECIES", all.x = TRUE)
# merge all of the different fruit counts into one column using coalesce
all_alones <- all_alones %>%
mutate(fruits = coalesce(NEW_FRUIT_COUNT, EXACTFR, TOTAL_INFL))
unique(all_alones$notes)
# removing all rows with notes
all_alones <- all_alones[!str_detect(all_alones$notes, "GONE|gone|dead|DEAD|herbivory|BT|GONE?|BS main stem"), ]
# getting rid of all columns except for PARK, SPECIES, PLOT, fruits
all_alones <- all_alones %>% select(PARK, SPECIES, PLOT, fruits)
# rename SPECIES to focal and fruits to seeds
all_alones <- all_alones %>%
rename(focal = SPECIES, seeds = fruits)
all_alones <- na.omit(all_alones)
alones_sem <- all_alones %>% filter(PARK == "SEM")
# find columns in diverse park data that are missing in the alones
missing_cols_sem <- setdiff(names(neighborhood_focal_sem), names(alones_sem))
# add missing columns to alones_br, filling with 0s
alones_sem[missing_cols_sem] <- 0
final_SEM_data <- rbind(neighborhood_focal_sem, alones_sem)
neighborhood_focal_sem
alones_sem
alones_sem <- all_alones %>% filter(PARK == "SEM")
alones_sem
neighborhood_focal_sem
alones_sem
neighborhood_focal_sem
alones_sem
neighborhood_focal_sem
neighborhood_focal_sem
alones_sem
# getting rid of park column
alones_sem <- alones_sem %>% select(-PARK)
# find columns in diverse park data that are missing in the alones
missing_cols_sem <- setdiff(names(neighborhood_focal_sem), names(alones_sem))
# add missing columns to alones_br, filling with 0s
alones_sem[missing_cols_sem] <- 0
neighborhood_focal_sem
alones_sem
final_SEM_data <- rbind(neighborhood_focal_sem, alones_sem)
cleaning_to_final_dataset <- function(final_data){
# before saving it as a csv,for stan data we have to replace all nas with 0s!
# also have to force the doubles to be ints, so also means rounding any decimals
neighbor_focal_all <- final_data %>%
mutate_all(~ ifelse(is.na(.), 0, .)) %>%
mutate_if(is.double, as.integer)
return (neighbor_focal_all)
}
sem_final_data <- cleaning_to_final_dataset(final_SEM_data)
# saving it as a csv!
write.csv(sem_final_data, "sem_final_data.csv")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
# loading in data (both focal and neighborhood data)
```{r}
library(tidyverse)
library(tidyverse)
library(stringr)
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
fix_col_names <- function(data){
#setting column names to values of 1st row
colnames(data) <- data [1, ]
# removing 1st row
data <- data[-1,]
return (data)
}
#wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
# filtering the neighborhoods so that we keep only the ones that have focal collects
# to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
# wir_focals_dat <- read.csv("focals/wir fitness(WIR diverse focals).csv")
# wir_neighborhoods_data <- read.csv("neighborhoods/wir fitness(WIR neighborhoods).csv")
#
# br_focals_dat <- read.csv("focals/br fitness(BR diverse focals).csv")
# br_neighborhoods_data <- read.csv("neighborhoods/br fitness(BR neighborhoods).csv")
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
# rf_focals_dat <- read.csv("focals/riverfront fitness(Riverfront Diverse focals).csv")
# rf_neighborhoods_data <- read.csv("neighborhoods/riverfront fitness(RIVERFRONT neighborhoods.csv")
fix_col_names <- function(data){
#setting column names to values of 1st row
colnames(data) <- data [1, ]
# removing 1st row
data <- data[-1,]
return (data)
}
#wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
#rf_neighborhoods_data <- fix_col_names(rf_neighborhoods_data)
#br_neighborhoods_data <- fix_col_names(br_neighborhoods_data)
# filtering the neighborhoods so that we keep only the ones that have focal collects
# to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
# wir doesn't have a 'focal collect' column
# rf also doesn't have a 'focal collect' column
# unique(br_neighborhoods_data$`focal collect?`), br focal collect column is just blanks ("")
# 11/19: just realized this is only true for Nav and Collom? Because for the rest of the plants we got, we would've gotten exact counts of fruits?
# TOPFR is number of fruits on the top infloresence
sem_focals_dat <- sem_focals_dat %>%
rename("TOP_INFL_FR" = "TOPFR")
# TOTALFR is the total number of infloresences
sem_focals_dat <- sem_focals_dat %>%
rename("TOTAL_INFL" = "TOTAL.FR")
# SIDEFR is the number of fruits on side infl
sem_focals_dat <- sem_focals_dat %>%
rename("SIDE_INFL_FR" = "SIDEFR")
# TODO: Think about what to do about the rows with special notes like BT, BT no fruits?, couldn't find, BT Fruit gone (leaning towards just dropping these)
#sem_focals_dat[sem_focals_dat$NOTES != "", ]
# would mean dropping 18 rows out of 203 rows
# what are all the unique notes, how many are there
# how many different variations of BT do we have
# "BT", "BT no fruits?", "BT Fruit gone", "BT BAGGED \"11\"?"
# "GONE", "couldn't find", I think these ones can definitely be dropped
# these are looking at the notes/the exact instances of the notes
# unique(sem_focals_dat$NOTES)
# BT_sem <- sem_focals_dat[str_detect(sem_focals_dat$NOTES, "BT"), ]
# GONE_sem <- sem_focals_dat[str_detect(sem_focals_dat$NOTES, "GONE|couldn't find"), ]
# I want to drop all of these, dropping the BT ~10 of these and dropping the GONE/couldn't find rows, ~10 of these
sem_focals_dat <- sem_focals_dat[!str_detect(sem_focals_dat$NOTES, "GONE|couldn't find|BT"), ]
sem_focals_dat
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
nav_and_collom_only_sem
View(nav_and_collom_alone)
View(nav_and_collom_only_sem)
sem_focals_dat[data[4, "SPECIES"]]
sem_focals_dat[4, "SPECIES"]
sem_focals_dat[sem_focals_dat$SPECIES == "CLAPUR", ]
sem_focals_dat[sem_focals_dat$SPECIES == "CLAPUR", ]
sem_focals_dat
clapur <- sem_focals_dat[sem_focals_dat$SPECIES == "CLAPUR", ]
clapur
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
# calculating the average side and tops in the function
#TODO: this doesn't differentiate between nav and collomia, it's just taking the
# averages of the entire column (need to make sure it's doing these separately)
# identify species for the row
species <- data[row, "SPECIES"]
# filter data for current species
species_data <- data[data$SPECIES == species, ]
average_top <- mean(data$TOP_INFL_FR, na.rm = TRUE)
average_side <- mean(data$SIDE_INFL_FR, na.rm = TRUE)
# making sure the averages are correct for each species
print(paste("Processing row:", row,
"| Species:", species,
"| Average TOP_INFL_FR:", round(average_top, 2),
"| Average SIDE_INFL_FR:", round(average_side, 2)))
# Error checking for the specific row
print(paste("Processing row:", row,
"TOTAL_INFL:", data[row, "TOTAL_INFL"],
"TOP_INFL_FR:", data[row, "TOP_INFL_FR"],
"SIDE_INFL_FR:", data[row, "SIDE_INFL_FR"]))
# TODO: need to think of another way to deal with these, there's at least one instance where there is no total infl, but there is a side and/or top infl count
if (is.na(data[row, "TOTAL_INFL"])) {
print(paste("Row", row, "- Skipping because TOTAL_INFL is NA"))
return(NA)
}
# If TOTAL_INFL == 1 and TOP_INFL_FR and SIDE_INFL_FR are present
else if (!is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"]) && (data[row, "TOTAL_INFL"] == 1)) {
print(paste("Row", row, "- Case: TOTAL_INFL == 1"))
return(data[row, "TOP_INFL_FR"] + data[row, "SIDE_INFL_FR"])
}
# If all values are present
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: All values present"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * data[row, "SIDE_INFL_FR"]))
}
# if side_infl and top infl are missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just side infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just top infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# Catch-all for unhandled cases
else {
print(paste("Row", row, "- Case: Unhandled"))
return(NA)
}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset and creating a column called 'new_fruit_count'
nav_and_collom_only_sem$new_fruit_count <- sapply(
1:nrow(nav_and_collom_only_sem),
function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem)
)
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
# calculating the average side and tops in the function
#TODO: this doesn't differentiate between nav and collomia, it's just taking the
# averages of the entire column (need to make sure it's doing these separately)
# identify species for the row
species <- data[row, "SPECIES"]
# filter data for current species
species_data <- data[data$SPECIES == species, ]
average_top <- mean(species_data$TOP_INFL_FR, na.rm = TRUE)
average_side <- mean(species_data$SIDE_INFL_FR, na.rm = TRUE)
# making sure the averages are correct for each species
print(paste("Processing row:", row,
"| Species:", species,
"| Average TOP_INFL_FR:", round(average_top, 2),
"| Average SIDE_INFL_FR:", round(average_side, 2)))
# Error checking for the specific row
print(paste("Processing row:", row,
"TOTAL_INFL:", data[row, "TOTAL_INFL"],
"TOP_INFL_FR:", data[row, "TOP_INFL_FR"],
"SIDE_INFL_FR:", data[row, "SIDE_INFL_FR"]))
# TODO: need to think of another way to deal with these, there's at least one instance where there is no total infl, but there is a side and/or top infl count
if (is.na(data[row, "TOTAL_INFL"])) {
print(paste("Row", row, "- Skipping because TOTAL_INFL is NA"))
return(NA)
}
# If TOTAL_INFL == 1 and TOP_INFL_FR and SIDE_INFL_FR are present
else if (!is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"]) && (data[row, "TOTAL_INFL"] == 1)) {
print(paste("Row", row, "- Case: TOTAL_INFL == 1"))
return(data[row, "TOP_INFL_FR"] + data[row, "SIDE_INFL_FR"])
}
# If all values are present
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: All values present"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * data[row, "SIDE_INFL_FR"]))
}
# if side_infl and top infl are missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just side infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just top infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# Catch-all for unhandled cases
else {
print(paste("Row", row, "- Case: Unhandled"))
return(NA)
}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset and creating a column called 'new_fruit_count'
nav_and_collom_only_sem$new_fruit_count <- sapply(
1:nrow(nav_and_collom_only_sem),
function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem)
)
# double checking averages
nav_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% "NAVSQU, ]
# double checking averages
nav_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% "NAVSQU", ]
# double checking averages
nav_sem <-  sem_focals_dat[sem_focals_dat$SPECIES =="NAVSQU", ]
nav_sem
nav_sem_side_mean <- mean(nav_sem$TOP_INFL_FR)
nav_sem_side_mean
nav_sem$TOP_INFL_FR
nav_sem_side_mean <- mean(nav_sem$TOP_INFL_FR, na.rm = TRUE)
nav_sem_side_mean
nav_sem$TOP_INFL_FR
nav_sem_top_mean <- mean(nav_sem$SIDE_INFL_FR)
nav_sem_top_mean
nav_sem$SIDE_INFL_FR
nav_sem_top_mean <- mean(nav_sem$SIDE_INFL_FR, na.rm = TRUE)
nav_sem_top_mean
collom_sem <-  sem_focals_dat[sem_focals_dat$SPECIES =="COLLOM", ]
collom_sem_side_mean <- mean(collom_sem$TOP_INFL_FR, na.rm = TRUE)
collom_sem_side_mean
collom_sem_top_mean <- mean(collom_sem$SIDE_INFL_FR, na.rm = TRUE)
collom_sem_top_mean
collom_sem$TOP_INFL_FR
collom_sem
mean(nav_and_collom_only_sem$TOP_INFL_FR, na.rm = TRUE)
mean(nav_and_collom_only_sem$SIDE_INFL_FR, na.rm = TRUE)
nav_and_collom_only_sem
collom_sem
nav_sem
rows_with_na_fruits
sem_epidens
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
# wir_focals_dat <- read.csv("focals/wir fitness(WIR diverse focals).csv")
# wir_neighborhoods_data <- read.csv("neighborhoods/wir fitness(WIR neighborhoods).csv")
#
# br_focals_dat <- read.csv("focals/br fitness(BR diverse focals).csv")
# br_neighborhoods_data <- read.csv("neighborhoods/br fitness(BR neighborhoods).csv")
sem_focals_dat <- read.csv("focals/sem fitness(SEM diverse focals.csv")
sem_neighborhoods_data <- read.csv("neighborhoods/sem fitness(sem neighborhoods).csv")
# rf_focals_dat <- read.csv("focals/riverfront fitness(Riverfront Diverse focals).csv")
# rf_neighborhoods_data <- read.csv("neighborhoods/riverfront fitness(RIVERFRONT neighborhoods.csv")
fix_col_names <- function(data){
#setting column names to values of 1st row
colnames(data) <- data [1, ]
# removing 1st row
data <- data[-1,]
return (data)
}
#wir_neighborhoods_data <- fix_col_names(wir_neighborhoods_data)
sem_neighborhoods_data <- fix_col_names(sem_neighborhoods_data)
#rf_neighborhoods_data <- fix_col_names(rf_neighborhoods_data)
#br_neighborhoods_data <- fix_col_names(br_neighborhoods_data)
# filtering the neighborhoods so that we keep only the ones that have focal collects
# to be merged with the focal data
sem_neighbors_filtered <- sem_neighborhoods_data[sem_neighborhoods_data$`focal collect?` == "Y", ]
# wir doesn't have a 'focal collect' column
# rf also doesn't have a 'focal collect' column
# unique(br_neighborhoods_data$`focal collect?`), br focal collect column is just blanks ("")
# 11/19: just realized this is only true for Nav and Collom? Because for the rest of the plants we got, we would've gotten exact counts of fruits?
# TOPFR is number of fruits on the top infloresence
sem_focals_dat <- sem_focals_dat %>%
rename("TOP_INFL_FR" = "TOPFR")
# TOTALFR is the total number of infloresences
sem_focals_dat <- sem_focals_dat %>%
rename("TOTAL_INFL" = "TOTAL.FR")
# SIDEFR is the number of fruits on side infl
sem_focals_dat <- sem_focals_dat %>%
rename("SIDE_INFL_FR" = "SIDEFR")
# TODO: Think about what to do about the rows with special notes like BT, BT no fruits?, couldn't find, BT Fruit gone (leaning towards just dropping these)
#sem_focals_dat[sem_focals_dat$NOTES != "", ]
# would mean dropping 18 rows out of 203 rows
# what are all the unique notes, how many are there
# how many different variations of BT do we have
# "BT", "BT no fruits?", "BT Fruit gone", "BT BAGGED \"11\"?"
# "GONE", "couldn't find", I think these ones can definitely be dropped
# these are looking at the notes/the exact instances of the notes
# unique(sem_focals_dat$NOTES)
# BT_sem <- sem_focals_dat[str_detect(sem_focals_dat$NOTES, "BT"), ]
# GONE_sem <- sem_focals_dat[str_detect(sem_focals_dat$NOTES, "GONE|couldn't find"), ]
# I want to drop all of these, dropping the BT ~10 of these and dropping the GONE/couldn't find rows, ~10 of these
sem_focals_dat <- sem_focals_dat[!str_detect(sem_focals_dat$NOTES, "GONE|couldn't find|BT"), ]
# doing the fruit count
calculate_new_fruit_count <- function(row, data){
# calculating the average side and tops in the function
#TODO: this doesn't differentiate between nav and collomia, it's just taking the
# averages of the entire column (need to make sure it's doing these separately)
# identify species for the row
species <- data[row, "SPECIES"]
# filter data for current species
species_data <- data[data$SPECIES == species, ]
average_top <- mean(species_data$TOP_INFL_FR, na.rm = TRUE)
average_side <- mean(species_data$SIDE_INFL_FR, na.rm = TRUE)
# making sure the averages are correct for each species
print(paste("Processing row:", row,
"| Species:", species,
"| Average TOP_INFL_FR:", round(average_top, 2),
"| Average SIDE_INFL_FR:", round(average_side, 2)))
# Error checking for the specific row
print(paste("Processing row:", row,
"TOTAL_INFL:", data[row, "TOTAL_INFL"],
"TOP_INFL_FR:", data[row, "TOP_INFL_FR"],
"SIDE_INFL_FR:", data[row, "SIDE_INFL_FR"]))
# TODO: need to think of another way to deal with these, there's at least one instance where there is no total infl, but there is a side and/or top infl count
if (is.na(data[row, "TOTAL_INFL"])) {
print(paste("Row", row, "- Skipping because TOTAL_INFL is NA"))
return(NA)
}
# If TOTAL_INFL == 1 and TOP_INFL_FR and SIDE_INFL_FR are present
else if (!is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"]) && (data[row, "TOTAL_INFL"] == 1)) {
print(paste("Row", row, "- Case: TOTAL_INFL == 1"))
return(data[row, "TOP_INFL_FR"] + data[row, "SIDE_INFL_FR"])
}
# If all values are present
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: All values present"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * data[row, "SIDE_INFL_FR"]))
}
# if side_infl and top infl are missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just side infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && !is.na(data[row, "TOP_INFL_FR"]) && is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(data[row, "TOP_INFL_FR"] + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# if just top infl is missing
else if (!is.na(data[row, "TOTAL_INFL"]) && is.na(data[row, "TOP_INFL_FR"]) && !is.na(data[row, "SIDE_INFL_FR"])) {
print(paste("Row", row, "- Case: SIDE_INFL and TOP_INFL_FR missing"))
return(average_top + ((data[row, "TOTAL_INFL"] - 1) * (average_side)))
}
# Catch-all for unhandled cases
else {
print(paste("Row", row, "- Case: Unhandled"))
return(NA)
}
}
# only want to apply the function to NAV and COLLOM
nav_and_collom <- c("NAVSQU", "COLLOM")
# double checking averages, the function says top: 17.75, side: 2.12
# nav_sem <-  sem_focals_dat[sem_focals_dat$SPECIES =="NAVSQU", ]
# nav_sem_side_mean <- mean(nav_sem$TOP_INFL_FR, na.rm = TRUE)
# nav_sem_top_mean <- mean(nav_sem$SIDE_INFL_FR, na.rm = TRUE)
# collom_sem <-  sem_focals_dat[sem_focals_dat$SPECIES =="COLLOM", ]
# collom_sem_side_mean <- mean(collom_sem$TOP_INFL_FR, na.rm = TRUE)
# collom_sem_top_mean <- mean(collom_sem$SIDE_INFL_FR, na.rm = TRUE)
# filtering dataframe for just nav and collom
nav_and_collom_only_sem <-  sem_focals_dat[sem_focals_dat$SPECIES %in% nav_and_collom, ]
# applying function to the filtered nav/collom dataset and creating a column called 'new_fruit_count'
nav_and_collom_only_sem$new_fruit_count <- sapply(
1:nrow(nav_and_collom_only_sem),
function(row) calculate_new_fruit_count(row, nav_and_collom_only_sem)
)
# JUST FOR NAV AND COLLOM, merging our new values created from the above sapply in the "new_fruit_count", using coalesce to see if there's new values in new_fruit_count, if not, taking from TOTAL_INFL column
nav_and_collom_only_sem <- nav_and_collom_only_sem %>%
mutate(fruits = coalesce(new_fruit_count, TOTAL_INFL))
#so the new column with all of the fruit counts is now in a column called "fruits"
# Merge the new column back to the original dataframe
# removing all nav and collom instances from the main dataframe so that we can merge our newly created fruit counts for ONLY nav and collom back into the larger dataset
sem_focals_dat_no_nav_or_collom <- sem_focals_dat[!(sem_focals_dat$SPECIES %in% c("NAVSQU", "COLLOM")), ]
# coalesce fruits for epiden (EXACTFR) and the rest of the focal species (TOTAL_INFL) into one fruits column
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>%
mutate(fruits = coalesce(EXACTFR, TOTAL_INFL))
# we are really only interested in the columns: fruits, species, and keeping plot, plot.1, subplot, and park for merging purposes
nav_and_collom_only_sem <- nav_and_collom_only_sem %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
sem_focals_dat_no_nav_or_collom <- sem_focals_dat_no_nav_or_collom %>% select(PLOT, SPECIES, PLOT.1, SUBPLOT, fruits, PARK)
# now merging the nav_and_collom_only_sem with sem_focals_dat_no_nav_or_collom to get the full dataset!!
sem_updated_focals <- rbind(sem_focals_dat_no_nav_or_collom, nav_and_collom_only_sem)
# still have NA values here in the fruits column, there's quite a few just from looking
# Show rows with NA in the 'fruits' column
rows_with_na_fruits <- sem_updated_focals[is.na(sem_updated_focals$fruits), ]
print(rows_with_na_fruits)
# basically all of the NAs are EPIDEN, of 28 na fruit values, there's two collom, 1 navsqu, and 1 gilcap
# TODO: rethinking how to go about getting the epiden fruit values, would an average of the fruit counts we do have be oversimplifying it too much?
sem_epidens <- sem_updated_focals[sem_updated_focals$SPECIES == "EPIDEN" , ]
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$EXACT)
# TODO: for now, just getting rid of all NAs
sem_updated_focals <- na.omit(sem_updated_focals)
sem_epidens
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$fruits)
# we have the fruit counts of 8 EPIDEN, out of 32
mean(sem_epidens$fruits, na.rm = TRUE)
# we have the fruit counts of 8 EPIDEN, out of 32
mean_fruits_sem_epiden <- mean(sem_epidens$fruits, na.rm = TRUE)
